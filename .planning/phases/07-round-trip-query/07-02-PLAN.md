---
phase: 07-round-trip-query
plan: 02
type: execute
wave: 2
depends_on:
  - "07-01"
files_modified:
  - src/components/round-trip-result.tsx
autonomous: true
requirements:
  - QURY-05

must_haves:
  truths:
    - "After form submit, both outbound and return train lists appear simultaneously"
    - "Outbound results fetch origin→destination for outboundDate"
    - "Return results fetch destination→origin for returnDate (legs swapped)"
    - "On mobile, outbound list stacks above return list (single column)"
    - "On desktop (md+), outbound and return lists appear side-by-side (two columns)"
    - "Each column has a heading showing leg direction and date"
    - "Each leg shows full train schedule with seat status badges and booking links — identical to single-query TrainCard/TrainTable"
    - "Each leg has independent loading, error, empty, and results states"
    - "React Query keys include 'outbound'/'return' discriminator — no cache deduplication between legs"
  artifacts:
    - path: "src/components/round-trip-result.tsx"
      provides: "RoundTripResult component with dual parallel queries"
      exports: ["RoundTripResult"]
  key_links:
    - from: "src/components/round-trip-result.tsx"
      to: "/api/tdx/trains"
      via: "two parallel useQuery calls with discriminated keys"
      pattern: "queryKey.*'outbound'|queryKey.*'return'"
    - from: "src/components/round-trip-result.tsx"
      to: "src/types/round-trip.ts"
      via: "import type RoundTripParams"
      pattern: "import.*RoundTripParams.*round-trip"
    - from: "src/components/round-trip-result.tsx"
      to: "src/components/train-card.tsx"
      via: "mobile card rendering per train"
      pattern: "TrainCard"
    - from: "src/components/round-trip-result.tsx"
      to: "src/components/train-table.tsx"
      via: "desktop table rendering"
      pattern: "TrainTable"
---

<objective>
Create RoundTripResult component that fires two parallel React Query fetches (outbound + return) with discriminated cache keys and renders results in a responsive side-by-side layout.

Purpose: The display half of the round-trip query — shows both legs simultaneously with full seat status and booking links, matching the quality of the single-query TrainList.

Output: `src/components/round-trip-result.tsx`
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-round-trip-query/07-RESEARCH.md
@.planning/phases/07-round-trip-query/07-01-SUMMARY.md
@src/components/train-list.tsx
@src/components/train-card.tsx
@src/components/train-table.tsx
@src/types/round-trip.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoundTripResult component</name>
  <files>src/components/round-trip-result.tsx</files>
  <action>
    Create `src/components/round-trip-result.tsx`. This component receives `params: RoundTripParams | null` and renders both legs in a responsive grid.

    **Imports:**
    - 'use client'
    - useQuery from @tanstack/react-query
    - Button from @/components/ui/button, Skeleton from @/components/ui/skeleton
    - TrainCard from @/components/train-card
    - TrainTable from @/components/train-table
    - RoundTripParams from @/types/round-trip
    - TdxEnrichedTrain from @/types/tdx

    **Local fetchTrains function** (same pattern as train-list.tsx, copy verbatim):
    ```typescript
    async function fetchTrains(origin: string, destination: string, date: string): Promise<TdxEnrichedTrain[]> {
      const url = `/api/tdx/trains?origin=${origin}&destination=${destination}&date=${date}`
      const res = await fetch(url)
      if (!res.ok) {
        const body = await res.json().catch(() => ({}))
        throw new Error(body.error ?? `查詢失敗（HTTP ${res.status}）`)
      }
      return res.json()
    }
    ```

    **Two parallel useQuery calls — CRITICAL: discriminated keys prevent cache deduplication:**
    ```typescript
    const { data: outboundData, isLoading: outboundLoading, isError: outboundError, error: outboundErr, refetch: refetchOutbound } = useQuery({
      queryKey: ['trains', 'outbound', params],
      queryFn: () => fetchTrains(params!.origin, params!.destination, params!.outboundDate),
      enabled: !!params,
      staleTime: 5 * 60 * 1000,
      retry: 1,
    })

    const { data: returnData, isLoading: returnLoading, isError: returnError, error: returnErr, refetch: refetchReturn } = useQuery({
      queryKey: ['trains', 'return', params],
      queryFn: () => fetchTrains(params!.destination, params!.origin, params!.returnDate),
      enabled: !!params,
      staleTime: 5 * 60 * 1000,
      retry: 1,
    })
    ```

    Note: return leg swaps origin/destination AND uses returnDate — both are easy to miss. The 'outbound'/'return' literal in queryKey is mandatory — without it, React Query deduplicates structurally-identical params and both legs return outbound data.

    **LegDisplay sub-component** (internal, not exported):
    ```typescript
    interface LegDisplayProps {
      heading: string       // e.g. "去程 · 2024-03-15"
      params: { origin: string; destination: string; date: string } | null
      data: TdxEnrichedTrain[] | undefined
      isLoading: boolean
      isError: boolean
      error: Error | null
      refetch: () => void
    }
    ```
    LegDisplay renders:
    - `<h3 className="text-sm font-semibold mb-3">{heading}</h3>`
    - Loading: 3 TrainSkeletons (use inline skeleton JSX matching train-list.tsx pattern — 3 cards with h-5/h-4/h-8 skeletons)
    - Error: error message + retry Button (variant="outline" size="sm")
    - Empty: `<p className="text-center text-muted-foreground py-8">無符合的班次</p>`
    - Results: mobile `md:hidden` TrainCard list + desktop `hidden md:block` TrainTable (same responsive pattern as train-list.tsx)

    **RoundTripResult main component:**
    ```typescript
    interface RoundTripResultProps {
      params: RoundTripParams | null
    }

    export function RoundTripResult({ params }: RoundTripResultProps) { ... }
    ```

    - If `!params`: render idle state `<p className="text-center text-muted-foreground py-12">選擇起訖站與去回程日期，即可查詢時刻表</p>`
    - If params: render the two-column grid:
      ```tsx
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <LegDisplay
            heading={`去程 · ${params.outboundDate}`}
            params={{ origin: params.origin, destination: params.destination, date: params.outboundDate }}
            data={outboundData}
            isLoading={outboundLoading}
            isError={outboundError}
            error={outboundErr as Error | null}
            refetch={refetchOutbound}
          />
        </div>
        <div>
          <LegDisplay
            heading={`回程 · ${params.returnDate}`}
            params={{ origin: params.destination, destination: params.origin, date: params.returnDate }}
            data={returnData}
            isLoading={returnLoading}
            isError={returnError}
            error={returnErr as Error | null}
            refetch={refetchReturn}
          />
        </div>
      </div>
      ```
  </action>
  <verify>Run `npx tsc --noEmit` — no TypeScript errors. Verify the two queryKey arrays contain the 'outbound' and 'return' string literals respectively. Verify the return leg queryFn swaps origin/destination and uses returnDate.</verify>
  <done>src/components/round-trip-result.tsx exports RoundTripResult, compiles without TypeScript errors, implements two parallel useQuery calls with discriminated keys ['trains','outbound',params] and ['trains','return',params], return leg uses swapped origin/destination, responsive grid layout (grid-cols-1 / md:grid-cols-2), each leg has full loading/error/empty/results states.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors related to round-trip-result.tsx
2. queryKey for outbound is `['trains', 'outbound', params]`
3. queryKey for return is `['trains', 'return', params]`
4. Return leg queryFn uses `params!.destination` as origin and `params!.origin` as destination (swapped)
5. Return leg queryFn uses `params!.returnDate` (not outboundDate)
6. Responsive layout: `grid grid-cols-1 md:grid-cols-2 gap-4`
7. Each leg renders TrainCard (mobile) and TrainTable (desktop) — same as TrainList
</verification>

<success_criteria>
- RoundTripResult compiles cleanly
- Two parallel queries with discriminated keys ('outbound'/'return') — verified by code inspection
- Return leg correctly uses swapped stations and returnDate
- Responsive two-column layout on desktop, stacked on mobile
- Each column has independent loading/error/empty/results state machine
</success_criteria>

<output>
After completion, create `.planning/phases/07-round-trip-query/07-02-SUMMARY.md` following the summary template.
</output>
