---
phase: 06-saved-favorite-routes
plan: 03
type: execute
wave: 3
depends_on: [06-01, 06-02]
files_modified:
  - src/app/page.tsx
autonomous: false
requirements: [PERS-01, PERS-03]

must_haves:
  truths:
    - "Saving a route from the form causes a chip to appear immediately above the form"
    - "Clicking a chip fills the origin and destination selects — does not auto-submit"
    - "Deleting a chip removes it immediately from the list"
    - "Saved routes survive page refresh (localStorage persists)"
    - "next build exits 0 — SSR-safe hook pattern prevents ReferenceError at prerender time"
    - "FavoriteRouteChips receives a stations list for Chinese name resolution"
    - "stations query is shared with QueryForm via React Query cache — no duplicate fetches"
  artifacts:
    - path: "src/app/page.tsx"
      provides: "Full favorites integration: useFavorites hook, handleApplyFavorite, FavoriteRouteChips above QueryForm"
      contains: "useFavorites"
  key_links:
    - from: "src/app/page.tsx"
      to: "src/hooks/use-favorites.ts"
      via: "useFavorites() hook call"
      pattern: "useFavorites"
    - from: "src/app/page.tsx"
      to: "src/components/favorite-route-chips.tsx"
      via: "FavoriteRouteChips rendered inside by-od TabsContent above QueryForm"
      pattern: "FavoriteRouteChips"
    - from: "src/app/page.tsx"
      to: "src/components/query-form.tsx"
      via: "onSave={...} and isFavoriteFull={isFull} props"
      pattern: "onSave.*isFavoriteFull"
---

<objective>
Wire the favorites feature into page.tsx: lift the stations query, call useFavorites, implement handleApplyFavorite, and render FavoriteRouteChips above QueryForm in the by-od tab. Verify next build passes.

Purpose: This plan completes the feature end-to-end. All data flows from useFavorites through page.tsx callbacks into both FavoriteRouteChips and QueryForm. Lifting the stations query to page.tsx gives FavoriteRouteChips access to station names without prop-drilling a resolver function.
Output: Modified page.tsx with full favorites integration; next build passes; human verification of all 6 user flows.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-saved-favorite-routes/06-RESEARCH.md
@.planning/phases/06-saved-favorite-routes/06-01-SUMMARY.md
@.planning/phases/06-saved-favorite-routes/06-02-SUMMARY.md
@src/app/page.tsx
@src/components/query-form.tsx
@src/components/favorite-route-chips.tsx
@src/hooks/use-favorites.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire page.tsx with favorites integration</name>
  <files>src/app/page.tsx</files>
  <action>
Read the current src/app/page.tsx first, then make the following targeted additions:

**1. Add imports at the top:**
```typescript
import { useQuery } from '@tanstack/react-query'
import { FavoriteRouteChips } from '@/components/favorite-route-chips'
import { useFavorites } from '@/hooks/use-favorites'
import type { FavoriteRoute } from '@/types/favorites'
import type { TdxStation } from '@/types/tdx'
```

Note: useQuery is already imported in query-form.tsx but page.tsx does not import it yet — add it here.

**2. Add stations fetch function above the component (alongside any existing fetch helpers, or at the top of the file):**
```typescript
async function fetchStations(): Promise<TdxStation[]> {
  const res = await fetch('/api/tdx/stations')
  if (!res.ok) throw new Error('Failed to load stations')
  return res.json()
}
```

This uses the same queryKey=['stations'] as QueryForm — React Query deduplicates the fetch. Both components share the same cached result with no extra network requests.

**3. Inside the Home component, add after the existing useState declarations:**
```typescript
// Stations for FavoriteRouteChips name resolution (same queryKey as QueryForm — React Query deduplicates)
const { data: stations = [] } = useQuery({
  queryKey: ['stations'],
  queryFn: fetchStations,
  staleTime: 24 * 60 * 60 * 1000,  // 24h — same cache config as QueryForm
})

// Favorites state and actions
const { favorites, addRoute, removeRoute, isFull } = useFavorites()
```

**4. Add handleApplyFavorite function (alongside the existing handleQuerySubmit and handleParamInit):**
```typescript
// Called when user clicks a favorite chip — fills form fields only, no auto-submit
// Per PERS-03: "一鍵帶入查詢表單起訖站" — bring into form, not auto-execute
function handleApplyFavorite(route: FavoriteRoute) {
  setInitialOrigin(route.origin)
  setInitialDestination(route.destination)
  // Increment formKey to remount QueryForm — picks up new initialOrigin/Destination props
  // Same pattern used in handleParamInit for URL-param pre-fill (Phase 5)
  setFormKey(k => k + 1)
  // Do NOT auto-submit: user may want to change date before querying
}
```

**5. In the by-od TabsContent JSX, add FavoriteRouteChips above the QueryForm card div:**
```tsx
<TabsContent value="by-od">
  {/* Favorite route chips — renders null when favorites is empty */}
  <FavoriteRouteChips
    favorites={favorites}
    stations={stations}
    onApply={handleApplyFavorite}
    onRemove={removeRoute}
  />
  <div className="mb-6 rounded-lg border bg-card p-4 shadow-sm">
    <QueryForm
      key={formKey}
      initialOrigin={initialOrigin}
      initialDestination={initialDestination}
      initialDate={initialDate}
      onSubmit={handleQuerySubmit}
      onSave={(origin, destination) => addRoute({ origin, destination })}
      isFavoriteFull={isFull}
    />
  </div>
  {queryParams && (
    <div className="mb-4 flex justify-end">
      <ShareButton params={queryParams} />
    </div>
  )}
  <TrainList params={queryParams} />
</TabsContent>
```

The `onSave` prop wraps `addRoute` in an inline arrow function to adapt the (origin, destination) signature to the FavoriteRoute object shape.

Keep all existing Phase 5 code unchanged: Suspense+SearchParamsInit, handleParamInit, handleQuerySubmit with router.replace, ShareButton, and the by-train and by-station tabs.
  </action>
  <verify>
`npx tsc --noEmit` exits 0.
`npm run build` exits 0 (next build — verifies SSR safety of new localStorage hook).
  </verify>
  <done>
src/app/page.tsx imports and calls useFavorites, renders FavoriteRouteChips above QueryForm card in the by-od tab, passes onSave and isFavoriteFull props to QueryForm, handleApplyFavorite uses formKey increment pattern. next build exits 0.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify all favorites user flows</name>
  <action>Run `npm run dev`, open http://localhost:3000, and manually verify all 6 user flows listed in how-to-verify.</action>
  <verify>All 6 flows pass: save, apply, delete, refresh persistence, capacity enforcement, no console errors.</verify>
  <done>User confirms "approved" after verifying all 6 flows.</done>
  <what-built>
Complete Phase 6 favorites feature wired end-to-end:
- useLocalStorage SSR-safe hook (two-useEffect pattern)
- useFavorites domain hook (addRoute silently skips duplicates, blocks past 10)
- FavoriteRouteChips component (chip list with delete button)
- QueryForm extended with save button (hidden when full)
- page.tsx wired: stations lifted, useFavorites integrated, chips rendered above form
  </what-built>
  <how-to-verify>
Run `npm run dev` and open http://localhost:3000

1. **Save a route:** Select an origin and destination in the "時間查詢" tab. A "儲存路線" button should appear below the "查詢" button. Click it. A chip appears above the form showing "起站 → 終站" in Chinese.

2. **Chip applies route:** Click the chip. The origin and destination selects should update to match the saved route. The query is NOT submitted automatically — only the form fields update.

3. **Chip delete works:** Click the X button inside a chip. The chip disappears. The form fields are not changed. Other chips remain.

4. **Persistence across refresh:** Save a route, then refresh the page (Cmd+R). The chip should reappear — data survived the reload via localStorage.

5. **Capacity enforcement:** Save 10 routes. After the 10th, the "儲存路線" button should disappear (hidden). Saving an 11th is impossible.

6. **No visible errors:** Browser console should show no React hydration warnings, no ReferenceError, no TypeScript errors.
  </how-to-verify>
  <resume-signal>Type "approved" if all 6 checks pass, or describe which check failed and what you observed.</resume-signal>
</task>

</tasks>

<verification>
`npm run build` exits 0 — confirms SSR-safe localStorage pattern (no ReferenceError during prerender).
Manual verification: save, apply, delete, refresh all work as specified above.
</verification>

<success_criteria>
- src/app/page.tsx: useFavorites imported and called, stations query lifted, FavoriteRouteChips rendered above QueryForm with correct props, QueryForm receives onSave + isFavoriteFull, handleApplyFavorite uses formKey increment
- Save button appears in QueryForm when origin+destination selected and not at capacity
- Clicking chip fills form fields without auto-submitting query
- Delete chip removes it immediately; other chips unaffected
- Saved routes persist after page refresh (localStorage)
- `npm run build` exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/06-saved-favorite-routes/06-03-SUMMARY.md`
</output>
