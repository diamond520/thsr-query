---
phase: 06-saved-favorite-routes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/favorites.ts
  - src/hooks/use-local-storage.ts
  - src/hooks/use-favorites.ts
autonomous: true
requirements: [PERS-01]

must_haves:
  truths:
    - "Saving a route persists it across page refreshes (localStorage)"
    - "Saving more than 10 routes is silently blocked"
    - "Saving a duplicate route is silently skipped"
    - "localStorage is never accessed outside useEffect (SSR-safe)"
  artifacts:
    - path: "src/types/favorites.ts"
      provides: "FavoriteRoute type, FAVORITES_STORAGE_KEY constant, FAVORITES_MAX constant"
      contains: "export interface FavoriteRoute"
    - path: "src/hooks/use-local-storage.ts"
      provides: "SSR-safe generic useLocalStorage<T> hook"
      exports: ["useLocalStorage"]
    - path: "src/hooks/use-favorites.ts"
      provides: "Domain hook: favorites array + addRoute + removeRoute + isFull"
      exports: ["useFavorites"]
  key_links:
    - from: "src/hooks/use-local-storage.ts"
      to: "window.localStorage"
      via: "useEffect (read on mount, write on change)"
      pattern: "useEffect.*localStorage"
    - from: "src/hooks/use-favorites.ts"
      to: "src/hooks/use-local-storage.ts"
      via: "useLocalStorage<FavoriteRoute[]>(FAVORITES_STORAGE_KEY, [])"
      pattern: "useLocalStorage"
---

<objective>
Create the data layer for saved favorite routes: the FavoriteRoute type, a generic SSR-safe useLocalStorage hook, and a useFavorites domain hook that wraps it.

Purpose: Establish the foundation that both the chip UI component and query form save button will depend on. The SSR-safe pattern is the critical constraint — localStorage must only be accessed inside useEffect to prevent ReferenceError during next build static prerendering.
Output: Three new files providing the complete favorites data layer, with no modifications to existing components.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-saved-favorite-routes/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FavoriteRoute type and constants</name>
  <files>src/types/favorites.ts</files>
  <action>
Create `src/types/favorites.ts` with:

```typescript
// src/types/favorites.ts

export interface FavoriteRoute {
  origin: string       // TDX StationID e.g. "1"
  destination: string  // TDX StationID e.g. "12"
}

export const FAVORITES_STORAGE_KEY = 'thsr-favorite-routes'
export const FAVORITES_MAX = 10
```

Store only StationID strings — not full TdxStation objects. Full objects bloat localStorage and create stale data issues when station data changes.
  </action>
  <verify>TypeScript: `npx tsc --noEmit` passes with no errors on this file.</verify>
  <done>File exists at src/types/favorites.ts, exports FavoriteRoute interface, FAVORITES_STORAGE_KEY string constant, and FAVORITES_MAX = 10 number constant.</done>
</task>

<task type="auto">
  <name>Task 2: Create SSR-safe useLocalStorage hook</name>
  <files>src/hooks/use-local-storage.ts</files>
  <action>
Create `src/hooks/use-local-storage.ts` using the two-useEffect pattern. This is mandatory for Next.js App Router — even 'use client' components execute on the server during static prerendering, so localStorage access in useState initializers causes `ReferenceError: localStorage is not defined` at build time.

```typescript
// src/hooks/use-local-storage.ts
'use client'

import { Dispatch, SetStateAction, useEffect, useState } from 'react'

export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, Dispatch<SetStateAction<T>>] {
  const [storedValue, setStoredValue] = useState<T>(initialValue)
  const [firstLoadDone, setFirstLoadDone] = useState(false)

  // Read from localStorage on mount — client-only, never runs on server
  useEffect(() => {
    try {
      const item = window.localStorage.getItem(key)
      if (item !== null) {
        setStoredValue(JSON.parse(item) as T)
      }
    } catch (error) {
      console.error('[useLocalStorage] read error', error)
    }
    setFirstLoadDone(true)
  }, [key])

  // Write to localStorage whenever storedValue changes, but only after the initial read
  // The firstLoadDone flag prevents writing the empty initial value before the read fires
  useEffect(() => {
    if (!firstLoadDone) return
    try {
      window.localStorage.setItem(key, JSON.stringify(storedValue))
    } catch (error) {
      console.error('[useLocalStorage] write error', error)
    }
  }, [storedValue, firstLoadDone, key])

  return [storedValue, setStoredValue]
}
```

The `firstLoadDone` flag is critical: without it, the write effect would fire on mount with the `initialValue` (empty array) and overwrite existing localStorage data before the read effect has a chance to load it.
  </action>
  <verify>`npx tsc --noEmit` passes. File contains no direct `localStorage` access outside `useEffect` bodies (grep: `localStorage` should only appear inside the two useEffect callbacks).</verify>
  <done>File exists at src/hooks/use-local-storage.ts, exports useLocalStorage function, uses 'use client' directive, implements two-useEffect pattern with firstLoadDone flag.</done>
</task>

<task type="auto">
  <name>Task 3: Create useFavorites domain hook</name>
  <files>src/hooks/use-favorites.ts</files>
  <action>
Create `src/hooks/use-favorites.ts` as a thin domain wrapper over useLocalStorage:

```typescript
// src/hooks/use-favorites.ts
import { useCallback } from 'react'
import { useLocalStorage } from './use-local-storage'
import type { FavoriteRoute } from '@/types/favorites'
import { FAVORITES_STORAGE_KEY, FAVORITES_MAX } from '@/types/favorites'

export function useFavorites() {
  const [favorites, setFavorites] = useLocalStorage<FavoriteRoute[]>(
    FAVORITES_STORAGE_KEY,
    []
  )

  const addRoute = useCallback((route: FavoriteRoute) => {
    setFavorites(prev => {
      // Silently skip duplicates (same origin AND destination)
      const isDuplicate = prev.some(
        r => r.origin === route.origin && r.destination === route.destination
      )
      // Silently block when at capacity
      if (isDuplicate || prev.length >= FAVORITES_MAX) return prev
      return [...prev, route]
    })
  }, [setFavorites])

  const removeRoute = useCallback((index: number) => {
    setFavorites(prev => prev.filter((_, i) => i !== index))
  }, [setFavorites])

  const isFull = favorites.length >= FAVORITES_MAX

  return { favorites, addRoute, removeRoute, isFull }
}
```

Use functional updater form (`prev => ...`) in both addRoute and removeRoute — this reads the latest state correctly even with batched React updates, preventing the race condition where multiple rapid clicks could bypass the FAVORITES_MAX check.
  </action>
  <verify>`npx tsc --noEmit` passes. Manual smoke test: confirm addRoute, removeRoute, isFull are all exported from the hook return value.</verify>
  <done>File exists at src/hooks/use-favorites.ts, exports useFavorites function, addRoute silently skips duplicates and blocks past FAVORITES_MAX=10, removeRoute uses filter by index.</done>
</task>

</tasks>

<verification>
Run `npx tsc --noEmit` from project root — must exit 0 with no errors.
The three new files must not import any new npm packages (only React built-ins and project-local paths).
</verification>

<success_criteria>
- src/types/favorites.ts: FavoriteRoute type + FAVORITES_STORAGE_KEY + FAVORITES_MAX exported
- src/hooks/use-local-storage.ts: useLocalStorage<T> with two-useEffect pattern, 'use client' directive
- src/hooks/use-favorites.ts: useFavorites returning { favorites, addRoute, removeRoute, isFull }
- `npx tsc --noEmit` exits 0
- No localStorage access outside useEffect bodies (SSR-safe)
</success_criteria>

<output>
After completion, create `.planning/phases/06-saved-favorite-routes/06-01-SUMMARY.md`
</output>
