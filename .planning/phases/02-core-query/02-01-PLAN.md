---
phase: 02-core-query
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/tdx.ts
  - src/fixtures/tdx-mock.ts
  - src/lib/tdx-api.ts
  - src/app/api/tdx/trains/route.ts
autonomous: true
requirements: [QURY-01, QURY-02]

must_haves:
  truths:
    - "GET /api/tdx/trains?origin=1&destination=12&date=2026-02-19 returns a JSON array of enriched train objects"
    - "Each train object has trainNo, departureTime, arrivalTime, standardSeat ('O'|'L'|'X'|null), businessSeat ('O'|'L'|'X'|null)"
    - "In mock mode (no TDX credentials), the endpoint returns at least 5 realistic train entries with seat status data"
    - "Missing origin/destination/date query params return 400 JSON error"
    - "TypeScript types TdxDailyTrain, TdxSeatStatus, TdxEnrichedTrain are exported from src/types/tdx.ts"
  artifacts:
    - path: "src/types/tdx.ts"
      provides: "Extended TDX type definitions for Phase 2"
      exports: ["TdxDailyTrain", "TdxSeatStatus", "TdxEnrichedTrain", "TdxSeatCode"]
    - path: "src/fixtures/tdx-mock.ts"
      provides: "Mock data for trains endpoint — enables dev without TDX credentials"
      contains: "MOCK_TRAINS"
    - path: "src/lib/tdx-api.ts"
      provides: "Server-side TDX API helpers — extended with fetchDailyTrains and fetchSeatStatus"
      exports: ["fetchDailyTrains", "fetchSeatStatus"]
    - path: "src/app/api/tdx/trains/route.ts"
      provides: "Route Handler: parallel fetch + server-side join, returns TdxEnrichedTrain[]"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/tdx/trains/route.ts"
      to: "src/lib/tdx-api.ts"
      via: "import fetchDailyTrains, fetchSeatStatus"
      pattern: "import.*fetchDailyTrains.*fetchSeatStatus.*from.*tdx-api"
    - from: "src/lib/tdx-api.ts"
      to: "TDX DailyTimetable/OD endpoint"
      via: "fetch with Bearer token (or MOCK_TRAINS in mock mode)"
      pattern: "DailyTimetable/OD"
    - from: "route.ts join logic"
      to: "seatMap.get(train.DailyTrainInfo.TrainNo)"
      via: "Map keyed on TrainNo — timetable as left dataset"
      pattern: "seatMap\\.get"
---

<objective>
Build the server-side data layer for Phase 2: extend TypeScript types, add mock fixtures for train data, extend the TDX API helper with two new fetch functions, and create the `/api/tdx/trains` Route Handler that parallel-fetches both TDX endpoints and joins them server-side.

Purpose: All Phase 2 UI plans (02-02 and 02-03) depend on `TdxEnrichedTrain` types. The Route Handler must exist before the client `useQuery` calls in `train-list.tsx` can work. This plan is the foundation that unblocks parallel UI work.

Output: Extended `src/types/tdx.ts`, extended `src/fixtures/tdx-mock.ts`, extended `src/lib/tdx-api.ts`, new `src/app/api/tdx/trains/route.ts`.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/tdx.ts
@src/fixtures/tdx-mock.ts
@src/lib/tdx-api.ts
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend TDX types and add mock train fixtures</name>
  <files>src/types/tdx.ts, src/fixtures/tdx-mock.ts</files>
  <action>
**src/types/tdx.ts** — append after the existing TdxStation interface (do NOT remove existing types):

```typescript
// --- Phase 2: Timetable + Seat Status types ---

/** TDX seat status code: O=充足, L=有限, X=售完 */
export type TdxSeatCode = 'O' | 'L' | 'X'

/** One stop in AvailableSeatStatusList response */
export interface TdxSeatStop {
  StopSequence: number
  StationID: string               // e.g. "1"
  StationName: TdxStationName
  NextStationID: string
  StandardSeatStatus: TdxSeatCode
  BusinessSeatStatus: TdxSeatCode
}

/** One train entry from GET /AvailableSeatStatusList/{StationID} */
export interface TdxSeatStatus {
  TrainNo: string                 // e.g. "0117"
  Direction: 0 | 1               // 0=southbound, 1=northbound
  StartingStationID: string
  EndingStationID: string
  StopStations: TdxSeatStop[]
}

/** One train entry from GET /DailyTimetable/OD/{O}/to/{D}/{Date} */
export interface TdxDailyTrain {
  DailyTrainInfo: {
    TrainNo: string              // e.g. "0115"
    TrainTypeName: TdxStationName
    Direction: 0 | 1
  }
  OriginStopTime: {
    StationID: string
    DepartureTime: string        // "HH:MM" format
  }
  DestinationStopTime: {
    StationID: string
    ArrivalTime: string          // "HH:MM" format
  }
}

/** Server-joined result returned from /api/tdx/trains */
export interface TdxEnrichedTrain {
  trainNo: string               // e.g. "0115"
  departureTime: string         // "HH:MM"
  arrivalTime: string           // "HH:MM"
  standardSeat: TdxSeatCode | null   // null if train not in seat status list
  businessSeat: TdxSeatCode | null
}
```

**src/fixtures/tdx-mock.ts** — append after MOCK_STATIONS (do NOT remove existing data):

```typescript
import type { TdxEnrichedTrain } from '@/types/tdx'

/** Mock enriched train data for /api/tdx/trains in mock mode.
 *  Covers all three seat status codes across 8 realistic trains (Nangang→Zuoying).
 *  Train numbers match real THSR format (4-digit, zero-padded).
 */
export const MOCK_TRAINS: TdxEnrichedTrain[] = [
  { trainNo: '0101', departureTime: '06:00', arrivalTime: '07:57', standardSeat: 'O', businessSeat: 'O' },
  { trainNo: '0103', departureTime: '06:30', arrivalTime: '08:10', standardSeat: 'O', businessSeat: 'O' },
  { trainNo: '0105', departureTime: '07:00', arrivalTime: '08:52', standardSeat: 'L', businessSeat: 'O' },
  { trainNo: '0107', departureTime: '08:00', arrivalTime: '09:52', standardSeat: 'L', businessSeat: 'L' },
  { trainNo: '0109', departureTime: '09:00', arrivalTime: '10:52', standardSeat: 'X', businessSeat: 'L' },
  { trainNo: '0111', departureTime: '10:00', arrivalTime: '11:52', standardSeat: 'X', businessSeat: 'X' },
  { trainNo: '0113', departureTime: '12:00', arrivalTime: '13:52', standardSeat: 'O', businessSeat: null },
  { trainNo: '0115', departureTime: '14:00', arrivalTime: '15:52', standardSeat: 'O', businessSeat: 'O' },
]
```

Note: MOCK_TRAINS uses `TdxEnrichedTrain` (the already-joined shape) to keep the mock simple — the Route Handler skips the join step in mock mode and returns MOCK_TRAINS directly. The `null` businessSeat on train 0113 tests the "—" display fallback.
  </action>
  <verify>Run `npx tsc --noEmit` — must complete with 0 errors. Also confirm: `grep -n "TdxEnrichedTrain\|TdxDailyTrain\|TdxSeatStatus" src/types/tdx.ts` shows all 5 new exports.</verify>
  <done>
    - `src/types/tdx.ts` exports: TdxSeatCode, TdxSeatStop, TdxSeatStatus, TdxDailyTrain, TdxEnrichedTrain (in addition to existing Phase 1 types)
    - `src/fixtures/tdx-mock.ts` exports MOCK_TRAINS with 8 entries covering all three status codes + null
    - TypeScript compiles with 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend tdx-api.ts and create /api/tdx/trains Route Handler</name>
  <files>src/lib/tdx-api.ts, src/app/api/tdx/trains/route.ts</files>
  <action>
**src/lib/tdx-api.ts** — append two new functions after the existing `fetchStations()` (do NOT remove anything):

```typescript
import type { TdxStation, TdxDailyTrain, TdxSeatStatus } from '@/types/tdx'
import { MOCK_STATIONS, MOCK_TRAINS } from '@/fixtures/tdx-mock'
// Update the existing imports line at top to add TdxDailyTrain and TdxSeatStatus

/**
 * Fetch THSR daily timetable for a specific OD pair and date.
 * Mock mode: Not called directly — Route Handler returns MOCK_TRAINS.
 * Real mode: GET /DailyTimetable/OD/{originId}/to/{destId}/{date}
 * Date format: YYYY-MM-DD. Returns trains in departure order.
 */
export async function fetchDailyTrains(
  originId: string,      // TDX StationID, e.g. "1" (not station name)
  destId: string,        // TDX StationID, e.g. "12"
  date: string           // e.g. "2026-02-19"
): Promise<TdxDailyTrain[]> {
  const token = await getTdxToken()
  const res = await fetch(
    `${TDX_BASE}/DailyTimetable/OD/${originId}/to/${destId}/${date}`,
    { headers: { Authorization: `Bearer ${token}` } }
    // No revalidate — route.ts sets force-dynamic
  )
  if (!res.ok) {
    throw new Error(`TDX DailyTimetable failed: ${res.status} ${res.statusText}`)
  }
  return res.json()
}

/**
 * Fetch seat availability for all trains at a given station.
 * Mock mode: Not called directly — Route Handler returns MOCK_TRAINS.
 * Real mode: GET /AvailableSeatStatusList/{stationId}
 * WARNING: Returns ALL trains at station (both directions, all OD pairs).
 * The Route Handler must use timetable result as the left join dataset.
 */
export async function fetchSeatStatus(stationId: string): Promise<TdxSeatStatus[]> {
  const token = await getTdxToken()
  const res = await fetch(
    `${TDX_BASE}/AvailableSeatStatusList/${stationId}`,
    { headers: { Authorization: `Bearer ${token}` } }
    // No revalidate — route.ts sets force-dynamic
  )
  if (!res.ok) {
    throw new Error(`TDX AvailableSeatStatusList failed: ${res.status} ${res.statusText}`)
  }
  return res.json()
}
```

Also update the import line at the top of `src/lib/tdx-api.ts` to include new types:
```typescript
import type { TdxStation, TdxDailyTrain, TdxSeatStatus } from '@/types/tdx'
import { MOCK_STATIONS, MOCK_TRAINS } from '@/fixtures/tdx-mock'
```

---

**Create `src/app/api/tdx/trains/route.ts`** (new file):

```typescript
// src/app/api/tdx/trains/route.ts
// GET /api/tdx/trains?origin=<StationID>&destination=<StationID>&date=<YYYY-MM-DD>
// Returns TdxEnrichedTrain[] — timetable joined with seat status.
// Uses force-dynamic: seat status changes every 10 minutes. Do NOT use revalidate.

import { isMockMode, fetchDailyTrains, fetchSeatStatus } from '@/lib/tdx-api'
import { MOCK_TRAINS } from '@/fixtures/tdx-mock'
import { NextResponse } from 'next/server'

export const dynamic = 'force-dynamic'  // CRITICAL: never cache — seat status is real-time

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const origin = searchParams.get('origin')           // TDX StationID, e.g. "1"
  const destination = searchParams.get('destination') // TDX StationID, e.g. "12"
  const date = searchParams.get('date')               // YYYY-MM-DD format

  if (!origin || !destination || !date) {
    return NextResponse.json(
      { error: 'Missing required parameters: origin, destination, date' },
      { status: 400 }
    )
  }

  // Mock mode: return fixture data without calling TDX API
  if (isMockMode()) {
    return NextResponse.json(MOCK_TRAINS)
  }

  try {
    // Parallel fetch — both TDX calls fired simultaneously (never sequential)
    const [trains, seatStatuses] = await Promise.all([
      fetchDailyTrains(origin, destination, date),
      fetchSeatStatus(origin),  // Seat status by ORIGIN StationID only
    ])

    // Build lookup map keyed on TrainNo for O(1) join
    // IMPORTANT: AvailableSeatStatusList returns ALL trains at station;
    // use timetable (trains array) as the left dataset — never the reverse.
    const seatMap = new Map(seatStatuses.map(s => [s.TrainNo, s]))

    const enriched = trains.map(train => {
      const trainNo = train.DailyTrainInfo.TrainNo
      const seat = seatMap.get(trainNo)
      // Find the StopStation leg where this train departs from origin station
      // StandardSeatStatus/BusinessSeatStatus represent the leg FROM this stop onward
      const leg = seat?.StopStations.find(stop => stop.StationID === origin)

      return {
        trainNo,
        departureTime: train.OriginStopTime.DepartureTime,  // "HH:MM"
        arrivalTime: train.DestinationStopTime.ArrivalTime, // "HH:MM"
        standardSeat: leg?.StandardSeatStatus ?? null,  // null = not in seat list
        businessSeat: leg?.BusinessSeatStatus ?? null,
      }
    })

    return NextResponse.json(enriched)
  } catch (error) {
    console.error('[/api/tdx/trains] Error:', error)
    return NextResponse.json(
      { error: 'Failed to fetch train data from TDX' },
      { status: 502 }
    )
  }
}
```
  </action>
  <verify>
1. `npx tsc --noEmit` — 0 errors
2. `npm run dev` then: `curl "http://localhost:3000/api/tdx/trains?origin=1&destination=12&date=2026-02-19"` — returns JSON array with 8 objects, each having `trainNo`, `departureTime`, `arrivalTime`, `standardSeat`, `businessSeat`
3. `curl "http://localhost:3000/api/tdx/trains"` — returns `{"error":"Missing required parameters..."}` with status 400
4. Check no caching: response headers must NOT include `Cache-Control: s-maxage` (force-dynamic disables it)
  </verify>
  <done>
    - `src/lib/tdx-api.ts` exports `fetchDailyTrains` and `fetchSeatStatus` (in addition to existing Phase 1 functions)
    - `src/app/api/tdx/trains/route.ts` exists with `export const dynamic = 'force-dynamic'` and `export async function GET`
    - In mock mode, GET /api/tdx/trains returns 8 enriched trains (from MOCK_TRAINS)
    - Missing params return 400 JSON error
    - TypeScript compiles with 0 errors
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with 0 errors
- `curl "http://localhost:3000/api/tdx/trains?origin=1&destination=12&date=2026-02-19"` returns JSON array of 8 trains
- Each train object shape: `{ trainNo: string, departureTime: "HH:MM", arrivalTime: "HH:MM", standardSeat: "O"|"L"|"X"|null, businessSeat: "O"|"L"|"X"|null }`
- `curl "http://localhost:3000/api/tdx/trains"` returns 400 with error message
- `grep "force-dynamic" src/app/api/tdx/trains/route.ts` shows the export
- No TDX credential strings in .next/static/ (credential security maintained from Phase 1)
</verification>

<success_criteria>
- `TdxEnrichedTrain`, `TdxDailyTrain`, `TdxSeatStatus`, `TdxSeatCode` all exported from `src/types/tdx.ts`
- `MOCK_TRAINS` exported from `src/fixtures/tdx-mock.ts` with 8 entries (status codes: O, L, X + null represented)
- `fetchDailyTrains()` and `fetchSeatStatus()` exported from `src/lib/tdx-api.ts`
- `/api/tdx/trains` Route Handler returns `TdxEnrichedTrain[]` in mock mode
- TypeScript 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-query/02-01-SUMMARY.md`
</output>
