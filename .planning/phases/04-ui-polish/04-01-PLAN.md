---
phase: 04-ui-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/station-line-picker.tsx
  - src/components/query-form.tsx
autonomous: true
requirements:
  - UIUX-01

must_haves:
  truths:
    - "手機版起訖站選擇顯示為垂直線路圖，12 個車站排列於線段上"
    - "點擊車站第一下設定出發站，第二下設定到達站，不需下拉選單"
    - "南港顯示於最上方，左營顯示於最下方（北→南地理順序）"
    - "出發站與到達站以不同顏色標示，中間車站顯示淡色高亮"
    - "選取後提交查詢，行為與原有 Select 下拉選單完全一致"
    - "桌面版（md 以上）繼續使用原有 Select 下拉選單，無變化"
    - "交換按鈕點擊後，線路圖選取狀態正確更新"
  artifacts:
    - path: "src/components/station-line-picker.tsx"
      provides: "視覺化線路圖車站選擇元件"
      min_lines: 80
      exports: ["StationLinePicker"]
    - path: "src/components/query-form.tsx"
      provides: "QueryForm 整合 mobile picker + desktop selects"
      contains: "md:hidden"
  key_links:
    - from: "src/components/query-form.tsx"
      to: "src/components/station-line-picker.tsx"
      via: "import StationLinePicker + render inside md:hidden div"
      pattern: "StationLinePicker"
    - from: "src/components/station-line-picker.tsx"
      to: "onOriginChange / onDestinationChange props"
      via: "handleStationTap state machine"
      pattern: "onOriginChange|onDestinationChange"
---

<objective>
Build a visual THSR line station picker for mobile, replacing the two Select dropdowns with a tap-to-select vertical line interface. Desktop layout is unchanged.

Purpose: UIUX-01 requires mobile users to select origin/destination by tapping stations on a line map instead of using dropdowns.
Output: New `StationLinePicker` component + modified `QueryForm` with CSS-driven mobile/desktop swap.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/tdx.ts
@src/lib/utils.ts
@src/components/query-form.tsx
@src/components/train-list.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StationLinePicker component</name>
  <files>src/components/station-line-picker.tsx</files>
  <action>
Create `src/components/station-line-picker.tsx` as a new file with the following complete implementation:

```tsx
'use client'

import { useEffect, useState } from 'react'
import { cn } from '@/lib/utils'
import type { TdxStation } from '@/types/tdx'

interface StationLinePickerProps {
  stations: TdxStation[]
  origin: string
  destination: string
  onOriginChange: (id: string) => void
  onDestinationChange: (id: string) => void
  disabled?: boolean
}

type SelectionStep = 'origin' | 'destination'

function getStationState(
  stationId: string,
  origin: string,
  destination: string
): 'origin' | 'destination' | 'in-range' | 'default' {
  const id = parseInt(stationId)
  const o = origin ? parseInt(origin) : null
  const d = destination ? parseInt(destination) : null
  if (o !== null && id === o) return 'origin'
  if (d !== null && id === d) return 'destination'
  if (o !== null && d !== null) {
    const min = Math.min(o, d)
    const max = Math.max(o, d)
    if (id > min && id < max) return 'in-range'
  }
  return 'default'
}

export function StationLinePicker({
  stations,
  origin,
  destination,
  onOriginChange,
  onDestinationChange,
  disabled = false,
}: StationLinePickerProps) {
  const [step, setStep] = useState<SelectionStep>('origin')

  // Reset step to 'origin' when origin is cleared externally (e.g. swap button
  // when only origin was set, or full clear). Also handles swap-then-continue.
  useEffect(() => {
    if (!origin && !destination) setStep('origin')
    else if (!origin) setStep('origin')
  }, [origin, destination])

  // Sort stations by StationID numerically: 1 (南港) → 12 (左營), north to south.
  const sortedStations = [...stations].sort(
    (a, b) => parseInt(a.StationID) - parseInt(b.StationID)
  )

  function handleStationTap(stationId: string) {
    if (disabled) return

    // If both are already selected, tapping any station clears and restarts.
    if (origin && destination) {
      onOriginChange(stationId)
      onDestinationChange('')
      setStep('destination')
      return
    }

    if (step === 'origin') {
      onOriginChange(stationId)
      setStep('destination')
    } else {
      // destination step
      if (stationId === origin) {
        // Tapping origin again during destination step: deselect origin, restart.
        onOriginChange('')
        setStep('origin')
      } else {
        onDestinationChange(stationId)
        setStep('origin')
      }
    }
  }

  const originName = sortedStations.find(s => s.StationID === origin)?.StationName.Zh_tw
  const destinationName = sortedStations.find(s => s.StationID === destination)?.StationName.Zh_tw

  const stepLabel =
    step === 'origin'
      ? origin
        ? `出發：${originName}`
        : '請點選出發站'
      : destination
        ? `到達：${destinationName}`
        : '請點選到達站'

  return (
    <div className="space-y-3">
      {/* Step prompt */}
      <p className="text-sm text-muted-foreground text-center">{stepLabel}</p>

      {/* Line and station dots */}
      <div className="relative flex flex-col" role="listbox" aria-label="選擇起訖站">
        {/* Vertical connecting line — positioned behind dots */}
        <div className="absolute left-[19px] top-5 bottom-5 w-px bg-border" />

        {sortedStations.map(station => {
          const state = getStationState(station.StationID, origin, destination)
          const isSelected = state === 'origin' || state === 'destination'

          return (
            <div
              key={station.StationID}
              className="relative flex items-center gap-3 py-0.5"
            >
              {/* Station button — 44×44px touch target (WCAG 2.5.5) */}
              <button
                type="button"
                role="option"
                aria-selected={isSelected}
                aria-label={`${station.StationName.Zh_tw}${state === 'origin' ? ' (出發站)' : state === 'destination' ? ' (到達站)' : ''}`}
                disabled={disabled}
                onClick={() => handleStationTap(station.StationID)}
                className="relative z-10 flex items-center justify-center w-11 h-11 shrink-0 disabled:opacity-50"
              >
                {/* Visual dot: 12px circle with state-based color */}
                <span
                  className={cn(
                    'w-3 h-3 rounded-full border-2 transition-colors',
                    state === 'origin' && 'bg-primary border-primary',
                    state === 'destination' && 'bg-destructive border-destructive',
                    state === 'in-range' && 'bg-primary/30 border-primary/50',
                    state === 'default' && 'bg-background border-border'
                  )}
                />
              </button>

              {/* Station name + badge */}
              <div className="flex items-center gap-1.5 min-w-0">
                <span
                  className={cn(
                    'text-sm',
                    isSelected ? 'font-medium text-foreground' : 'text-muted-foreground'
                  )}
                >
                  {station.StationName.Zh_tw}
                </span>
                {state === 'origin' && (
                  <span className="text-[10px] font-medium text-primary-foreground bg-primary px-1 rounded">
                    起
                  </span>
                )}
                {state === 'destination' && (
                  <span className="text-[10px] font-medium text-destructive-foreground bg-destructive px-1 rounded">
                    訖
                  </span>
                )}
              </div>
            </div>
          )
        })}
      </div>
    </div>
  )
}
```

Key implementation details:
- `getStationState` is a pure function outside the component — no closure over state, easier to test.
- The `useEffect` watching `[origin, destination]` resets `step` to 'origin' when origin is cleared, handling the swap-then-continue edge case (Pitfall 3 from research).
- `left-[19px]` positions the line at center of the 44px (w-11) button: (44/2) - (1/2) ≈ 19px from left edge of the relative container.
- `top-5 bottom-5` (20px insets) aligns line endpoints with the center of the first and last dot.
- `py-0.5` gives 2px vertical padding per row — compact but not cramped for 12 stations.
- Do NOT use `useMediaQuery` JS hook — CSS breakpoints only to avoid hydration issues.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors in the new file.</verify>
  <done>
    - `src/components/station-line-picker.tsx` exists and exports `StationLinePicker`
    - TypeScript is satisfied: TdxStation type used correctly, all props typed, no `any`
    - `getStationState` handles all four states: 'origin', 'destination', 'in-range', 'default'
    - `useEffect` resets step when origin is cleared
    - Button touch targets are w-11 h-11 (44px), visual dot is a child span
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate picker into QueryForm + build verification</name>
  <files>src/components/query-form.tsx</files>
  <action>
Modify `src/components/query-form.tsx` to add the mobile visual picker above the existing Select row, using CSS-only responsive swap (same pattern as train-list.tsx).

**Changes required (minimal — do not alter any other logic):**

1. Add import at the top (after existing imports):
```tsx
import { StationLinePicker } from '@/components/station-line-picker'
```

2. Replace the existing station select row div (lines 78-119, currently `<div className="flex items-center gap-2">`):

```tsx
{/* Mobile: visual line picker (md:hidden) */}
<div className="md:hidden">
  <StationLinePicker
    stations={stations}
    origin={origin}
    destination={destination}
    onOriginChange={setOrigin}
    onDestinationChange={setDestination}
    disabled={stationsLoading}
  />
</div>

{/* Desktop: original Select row (hidden on mobile) */}
<div className="hidden md:flex items-center gap-2">
  {/* Origin station select */}
  <Select value={origin} onValueChange={setOrigin} disabled={stationsLoading}>
    <SelectTrigger className="flex-1 min-w-0">
      <SelectValue placeholder="起站" />
    </SelectTrigger>
    <SelectContent>
      {stations.map(station => (
        <SelectItem key={station.StationID} value={station.StationID}>
          {station.StationName.Zh_tw}
        </SelectItem>
      ))}
    </SelectContent>
  </Select>

  {/* Swap button — per user decision: circle-arrow icon, between the two selects */}
  <Button
    type="button"
    variant="outline"
    size="icon"
    onClick={handleSwap}
    disabled={!origin && !destination}
    aria-label="交換起訖站"
    className="shrink-0"
  >
    <ArrowLeftRight className="h-4 w-4" />
  </Button>

  {/* Destination station select */}
  <Select value={destination} onValueChange={setDestination} disabled={stationsLoading}>
    <SelectTrigger className="flex-1 min-w-0">
      <SelectValue placeholder="訖站" />
    </SelectTrigger>
    <SelectContent>
      {stations.map(station => (
        <SelectItem key={station.StationID} value={station.StationID}>
          {station.StationName.Zh_tw}
        </SelectItem>
      ))}
    </SelectContent>
  </Select>
</div>
```

The `handleSwap`, `handleSubmit`, `isValid`, date picker row, and submit button are unchanged. Only the station selection area is split into two breakpoint-conditional divs.

Note: The mobile picker does NOT include a swap button. On mobile, tapping a station when both are already selected clears and restarts selection from origin. This is the intended two-step UX — a separate swap button is desktop-only.

After making the edit, run the production build to verify no TypeScript errors:
```bash
npm run build
```
  </action>
  <verify>
    1. `npm run build` exits with code 0 (no TypeScript or compile errors).
    2. Grep confirms both patterns exist in query-form.tsx:
       - `md:hidden` (mobile picker wrapper)
       - `hidden md:flex` (desktop select row)
       - `StationLinePicker` import and usage
  </verify>
  <done>
    - `src/components/query-form.tsx` imports and renders `StationLinePicker` inside `md:hidden` div
    - Existing Select row is wrapped in `hidden md:flex items-center gap-2`
    - `npm run build` passes with exit code 0
    - `origin`, `destination`, `setOrigin`, `setDestination` are shared between mobile picker and desktop selects via existing QueryForm state — no new state introduced
    - `handleSubmit` and `isValid` remain unchanged; query behavior is identical to Phase 2
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript: `npx tsc --noEmit` passes with no errors.
2. Build: `npm run build` exits 0 — no compile errors in new or modified files.
3. Structure checks:
   - `src/components/station-line-picker.tsx` exports `StationLinePicker`
   - `src/components/query-form.tsx` contains `md:hidden` and `hidden md:flex`
   - `src/components/query-form.tsx` imports `StationLinePicker`
4. Station order: `sortedStations` sorted by `parseInt(StationID)` ascending guarantees 南港(1)→左營(12).
5. Touch targets: Every station `<button>` is `w-11 h-11` (44px) — visual dot is child `<span>`.
6. Pitfall guards:
   - Same-station guard: `if (stationId === origin)` during destination step → deselect + restart.
   - Step desync: `useEffect([origin, destination])` resets step when origin cleared.
   - Hydration: CSS-only breakpoints, no `useMediaQuery`.
</verification>

<success_criteria>
- Mobile: visual line picker with 12 stations in north-to-south order, tap-to-select origin then destination, 起/訖 badges on selected stations, in-range dots highlighted
- Desktop: existing Select dropdowns unchanged, no regression
- Form submission: `onSubmit({ origin, destination, date })` behavior identical to Phase 2 — same QueryParams shape, same validation (`origin !== destination` guard)
- `npm run build` passes: zero TypeScript errors across both files
</success_criteria>

<output>
After completion, create `.planning/phases/04-ui-polish/04-01-SUMMARY.md` using the summary template.
</output>